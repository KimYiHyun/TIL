# 기본 문법
### 변수의 이해
: 데이터 또는 자료를 담을 수 있는 메모리의 저장장소
- 변수 이름 규칙
- 숫자로 시작 x, 예약어 사용 x
- 일반적으로 정확하고 간단하게 변수 이름을 만드는 것이 원칙!
---

### 데이터 타입
- 정수(int), 실수(float), 문자열(str), 불리언(boolean) 등
- type 함수 : 해당 변수, 값의 타입(type)을 알고자 할 때 사용
```python
a = 2
b = 10.2

type(b)
```
- None : 아무런 값을 갖지 않을 때 사용
    
**1. 숫자형 데이터 타입**
- 산술 연산자  
![산술연산자](https://user-images.githubusercontent.com/56059126/175970010-ae751c1b-8123-440a-b605-a90c64392558.png)
- 비교 연산자 : bool 타입  
![비교연산자](https://user-images.githubusercontent.com/56059126/175971359-ecf45e4c-a6a9-469d-ba28-1dcbba91a96d.png)
  
**2. 문자형 데이터 타입**
- 여러 개의 문자로 구성된 자료, 자료 순서에 의미가 있다.
- ''(작은따옴표), ""(큰따옴표) 사용
- 이스케이프 문자
```python
print('Giand Pengsoo\n\n')   #new line
print("Peng\t-ha")           #tab 등
```
- 인덱스 : 문자열의 순서
[0, 문자열의 길이], 음수 인덱스 [-문자열의 길이, -1]  \\<!-- -1 : 가장 마지막 인덱스 -->
- 슬라이싱 : 문자열의 부분을 추출
```python
a = 'Giant Pengsoo'
print(a[0:3])
print(a[1:4])
print(a[3:])
```
- upper() : 영문자를 모두 대문자로 변환
- replace() : 문자열 내의 특정 문자를 치환
```python
a.replace("e", "i") 
```
- split() : 문자열을 특정한 문자로 구분하여 나눈다.
```python
a = 'This is Pengsoo'
print(a.split())
print(a.split('s'))
```  
  
**3. 리스트(list)**  
여러 형태의 데이터가 순서형으로 결합된 구조  
생성된 후에 변경가능(mutable)  
[]또는 list(), str.split()로 생성
```python
a = [1, 2, 3, 4, 5]
b = [1, 2, 'smu', 'kdata', [3, 4]]

c = 'This is PengSoo'
d = list(c)
print(d)

['T', 'h', 'i', 's', 'i', 's', 'P', 'e', 'n', 'g', 's', 'o', 'o']

c = 'This is PengSoo'
d = c.split()
print(d)

['This', 'is', 'Pengsoo']
```
- 인덱싱
문자열의 인덱싱과 동일
인덱스를 이용해 항목 변경 가능(숫자만, 문자열은 x)
- 슬라이싱
문자열 슬라이싱과 동일
슬라이싱 결과도 list
- 주요 함수
  - append() : 리스트 끝에 항목 추가
  ```python
  a = [1, 2, 3, 4, 5]
  a.append(10)
  ```
  - extend() : 리스트 연장
  ```python
  a = [1, 2, 3]
  b = [4, 5, 6]
  a.extend(b)
  print(a)
  
  [1, 2, 3, 4, 5, 6]
  ```
  - remove() : 값으로 항목 삭제
  ```python
  a = [1, 2, 3, 4, 5]
  a.remove(2)
  print(a)
  
  [1 ,3 , 4, 5]
  ```
  - insert() : 항목 추가, 앞에 인덱스, 뒤에 항목을 입력해 원하는 위치에 추가 가능
  ```python
  a = [1, 2, 3]
  a.insert(1,5)   #1번 인덱스에 5를 넣어라  
  print(a)
  
  [1, 5, 2, 3]
  ```
  - pop() : 지우고자 하는 아이템을 반환 후 삭제
  ```python
  a = [1, 2, 3, 4, 5]
  a.pop()
  print(a)
  
  [1, 2, 3, 4]
  ```
  - index() : 찾고자 하는 값의 인덱스 반환
  ```python
  a = [1, 2, 3, 4, 5]
  a.index(4)
  
  3
  ```
  - in : 리스트 내에 해당 값이 존재하는지 확인, True,False로 반환
  ```python
  a = [1, 2, 3, 4, 5]
  b = 4
  c = b in a
  print(c)
  
  True
  ```
  - sort() : 리스트 정렬
  - sorted() : 정렬된 리스트의 복사본 반환
  ```python
  a = [6, 3, 8, 2, 1, 3, 30, 21]
  a.sort()
  print(a)
  
  [1, 2, 3, 3, 6, 8, 21, 30]
  
  a = [6, 3, 8, 2, 1, 3, 30, 21]
  b = sorted(a)

  print(a)
  print(b)
  
  [6, 3, 8, 2, 1, 3, 30, 21]
  [1, 2, 3, 3, 6, 8, 21, 30]
  ```
  
  
**4. 튜플(tuple)**  
여러 형태의 데이터 결합이란 점에서 리스트와 유사하나  
값의 변경 불가능(immutable)하다는 점에서 차이가 있다.  
(), 또는 tuple()를 사용하여 생성
```python
a = [1, 2, 3]  #리스트
b = (1, 2, 3)  #튜플
print(type(a))

<class 'list'>
<class 'tuple'>
```
  
여러 개의 변수를 하나의 라인으로 생성할 때 사용
- tuple unpacking : 튜플의 값을 차례대로 변수에 대입
```python
a, b = 100, 200
print(a, b)

100 200
```
  
  
**5. 딕셔너리(dictionary)**  
키-값을 갖는 데이터 구조
- key : 고유한 값, 다른 값들과 구분할 수 있는 기준
- value : 각 key에 덧붙여진 정보  
사전 선언은 dict(), 또는 {}이며  
{key1:value1, key2:value2, key3:value3, ...} 형태로 구성  
키 값을 알면, 이에 해당하는 value를 불러올 수 있지만  
반대로 value를 알고 있어도 key값을 불러올 수는 없다.  
순서를 따지지 않음 = 인덱스가 없다.
```python
a = {'A':'apple', 'B':'banana', 'C':'carrot'}
print(a)

{'A': 'apple', 'B': 'banana', 'C': 'carrot'}
```
- 항목 추가 및 변경
기존에 키가 존재하면 새로운 값으로 추가
존재하지 않으면, 새로운 키-값 생성
```python
a = {'A':'apple', 'B':'banana', 'C':'carrot'}
a['M'] = 'mango'
print(a)

a = {'A':'apple', 'B':'banana', 'C':'carrot', 'M':'mango'}
```
- 주요 함수
  - update() : 두 딕셔너리를 병합
               겹치는 키가 있다면 parameter로 전달되는 키의 값이 덮어쓰기 됨.
  ```python
  a = {'a':1, 'b':2, 'c':3}
  b = {'a':2, 'b':3, 'c':4}

  a.update(b)
  print(a)
  
  {'a': 2, 'b': 3, 'c': 4}
  ```
  - pop() : key 삭제
  ```python
  a = {'a':1, 'b':2, 'c':3}
  a.pop('b')
  print(a)
  
  {'a': 1, 'c': 3}
  ```
  - del : key 삭제(del은 범용적으로 사용되는 키워드)
  ```python
  a = {'a':1, 'b':2, 'c':3}
  del a['b']
  print(a)
  
  {'a': 1, 'c': 3}
  ```
  - clear() : 딕셔너리의 모든 값을 초기화
  ```python
  a = {'a':1, 'b':2, 'c':3}
  a.clear()
  print(a)
  
  {}
  ```
  - in : key값 존재 확인
  ```python
  a = {'a':1, 'b':2, 'c':3}
  b = [1, 3, 5, 7, 9, 11, 13, 15]
  print('b' in a)
  
  True
  ```
  - dict[key] : 값에 접근, key가 없는 경우 에러 발생
  - get() : 값에 접근, key가 없는 경우 none 반환
  ```python
  a = {'a':1, 'b':2, 'c':3}

  print(a.get('d'))
  print(a['d'])
  
  None
  에러 발생
  ```
  - keys() 키만 반환
  - values() : 값만 반환
  - items() : 키, 값의 튜플을 반환
  ```python
  a = {'a':1, 'b':2, 'c':3}
  print(a.keys())    #키만 반환
  print(a.values())  #값만 반환
  print(a.items())   #키, 값의 튜플을 반환
  
  dict_keys(['a', 'b', 'c'])
  dict_values([1, 2, 3])
  dict_items([('a', 1), ('b', 2), ('c', 3)])
  ```
  
  
**6. 집합(set)**  
딕셔너리에서 key만 활용하는 데이터 구조로 순서에 의미 x  
수학에서의 집합과 동일한 개념(중복된 값은 추가되지 않음)  
교집합, 합집합, 차집합 등 집합연산 가능  
{}, set()로 생성하며, 새로운 값을 추가, 삭제 가능
```python
a = {1, 1, 3, 5, 7, 7, 9}
print(a)

{1, 3, 5, 7, 9}
```
```python
a = [1, 1, 3, 5, 7, 7, 9]
b = set(a)
print(b)

{1, 3, 5, 7, 9}
```
- 집합연산
```python
a = {1, 2, 3, 4}
b = {1, 2, 4, 8}

print(a.union(b))
print(a.intersection(b))
print(a.difference(b))

{1, 2, 3, 4, 8}
{1, 2, 4}
{3}
```
